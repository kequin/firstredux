{"ast":null,"code":"export default function getMathHandler() {\n  const math = getMathFn();\n  let divByZero = false;\n  return applyMath;\n  /***/\n\n  function applyMath(math_str) {\n    divByZero = false;\n    throwUnmatchedScopes(math_str);\n    math_str = deepRemoveScopes(math_str);\n    math_str = autoCorrect(math_str);\n    let result = parseLinearMath(math_str);\n    return divByZero ? \"Караул, тут делят на ноль!\" : result;\n  }\n\n  function deepRemoveScopes(str) {\n    str = autoCorrect(str);\n    let index = str.indexOf(\"(\");\n    if (index === -1) return parseLinearMath(str);\n    let scope = \"(\";\n    let open = 1;\n\n    for (let i = index + 1; i <= 100000; i++) {\n      if (i === 100000) console.log(\"Кажется пошел бесконечный цикл\");\n      scope += str[i];\n\n      if (str[i] === \"(\") {\n        open++;\n      } else if (str[i] === \")\") {\n        open--;\n      }\n\n      if (open === 0) {\n        // Привет, рекурсия!\n        // Показалось проще перезапускать функцию после каждой найденной скобки.\n        // При этом учитывая и вложенные скобки scope.slice(1, -1)\n        return deepRemoveScopes(str.replace(scope, deepRemoveScopes(scope.slice(1, -1))));\n      }\n    }\n  }\n\n  function parseLinearMath(math_str) {\n    /* уже точно нет скобок */\n    math_str = autoCorrect(math_str);\n    math_str = mul_div(math_str);\n    math_str = plus_minus(math_str);\n    return math_str;\n    /***/\n\n    function mul_div(math_str) {\n      let length = (math_str.match(/\\/|\\*/g) || []).length;\n      if (!length) return math_str;\n\n      for (let i = 0; i < length; i++) {\n        math_str = math_str.replace(/(\\d+(?:\\.\\d+)?)(\\/|\\*)(-?\\d+(?:\\.\\d+)?)/, function (_, a, oper, b) {\n          return math(a, oper, b);\n        });\n        math_str = autoCorrect(math_str); // Строка не из миллиона символов, поэтому после каждой операции\n        // На всякий случай исправляется всё, что может пойти не так.\n        // В основном, \"гасятся\" знаки вида ++, +-, --\n      }\n\n      return math_str;\n    }\n\n    function plus_minus(math_str) {\n      let length = (math_str.match(/\\+|-/g) || []).length;\n      if (!length) return math_str;\n\n      for (let i = 0; i < length; i++) {\n        math_str = math_str.replace(/((?:^-)?\\d+(?:\\.\\d+)?)(\\+|-)(\\d+(?:\\.\\d+)?)/, function (_, a, oper, b) {\n          return math(a, oper, b);\n        });\n        math_str = autoCorrect(math_str);\n      }\n\n      return math_str;\n    }\n  }\n\n  function autoCorrect(math_str) {\n    return math_str // Замены:\n    .replace(/\\s/g, \"\") // Удалить все пробелы\n    .replace(/\\(\\)/g, \"\") // Убрать пустые скобки\n    .replace(/--/g, \"+\") // Два минуса подряд → Плюс\n    .replace(/(\\+\\+|\\*\\*|\\/\\/)/g, (_, oper) => oper[0]) // Двойные плюсы, умножения и пр → на один\n    .replace(/\\+-|-\\+/g, \"-\") // Плюс после минуса и наоборот → на минус\n    .replace(/\\)\\(/g, \")*(\") // Две скобки подряд → вставить умножение\n    .replace(/(\\d)\\(/g, \"$1*(\") // Число и сразу скобка → умножение\n    .replace(/\\)(\\d)/g, \")*$1\") // Скобка и сразу число → умножение\n    .replace(/(\\/|\\*)\\+/g, \"$1\") // *+ или /+ → убрать плюс\n    ;\n  }\n\n  function throwUnmatchedScopes(math_str) {\n    let scopes_open = (math_str.match(/\\(/g) || []).length;\n    let scopes_close = (math_str.match(/\\)/g) || []).length;\n\n    if (scopes_open !== scopes_close) {\n      throw new Error(\"Unmatched parenthesis at \" + math_str);\n    }\n  }\n\n  function getMathFn() {\n    let local_math = {\n      \"+\": (a, b) => Number(a) + Number(b),\n      \"-\": (a, b) => a - b,\n      \"*\": (a, b) => a * b,\n      \"/\": (a, b) => {\n        if (b === \"0\") {\n          divByZero = true;\n        }\n\n        return a / b;\n      }\n    };\n    return function math(a, operation, b) {\n      return local_math[operation](a, b);\n    };\n  }\n}","map":{"version":3,"sources":["/home/taiga/Рабочий стол/govno/firstredax/src/applyMath.js"],"names":["getMathHandler","math","getMathFn","divByZero","applyMath","math_str","throwUnmatchedScopes","deepRemoveScopes","autoCorrect","result","parseLinearMath","str","index","indexOf","scope","open","i","console","log","replace","slice","mul_div","plus_minus","length","match","_","a","oper","b","scopes_open","scopes_close","Error","local_math","Number","operation"],"mappings":"AAAA,eAAe,SAASA,cAAT,GAA0B;AACrC,QAAMC,IAAI,GAAGC,SAAS,EAAtB;AACA,MAAIC,SAAS,GAAG,KAAhB;AAEA,SAAOC,SAAP;AAEA;;AAEA,WAASA,SAAT,CAAmBC,QAAnB,EAA6B;AAC3BF,IAAAA,SAAS,GAAG,KAAZ;AACAG,IAAAA,oBAAoB,CAACD,QAAD,CAApB;AAEAA,IAAAA,QAAQ,GAAGE,gBAAgB,CAACF,QAAD,CAA3B;AACAA,IAAAA,QAAQ,GAAGG,WAAW,CAACH,QAAD,CAAtB;AAEA,QAAII,MAAM,GAAGC,eAAe,CAACL,QAAD,CAA5B;AACA,WAAOF,SAAS,GAAG,4BAAH,GAAkCM,MAAlD;AACD;;AAGD,WAASF,gBAAT,CAA0BI,GAA1B,EAA+B;AAC7BA,IAAAA,GAAG,GAAGH,WAAW,CAACG,GAAD,CAAjB;AAEA,QAAIC,KAAK,GAAGD,GAAG,CAACE,OAAJ,CAAY,GAAZ,CAAZ;AACA,QAAID,KAAK,KAAK,CAAC,CAAf,EAAmB,OAAOF,eAAe,CAACC,GAAD,CAAtB;AAEnB,QAAIG,KAAK,GAAG,GAAZ;AACA,QAAIC,IAAI,GAAG,CAAX;;AAEA,SAAK,IAAIC,CAAC,GAAGJ,KAAK,GAAG,CAArB,EAAwBI,CAAC,IAAI,MAA7B,EAAqCA,CAAC,EAAtC,EAA2C;AACzC,UAAIA,CAAC,KAAK,MAAV,EAAmBC,OAAO,CAACC,GAAR,CAAY,gCAAZ;AAEnBJ,MAAAA,KAAK,IAAIH,GAAG,CAACK,CAAD,CAAZ;;AAEA,UAAIL,GAAG,CAACK,CAAD,CAAH,KAAW,GAAf,EAAqB;AACnBD,QAAAA,IAAI;AACL,OAFD,MAEO,IAAIJ,GAAG,CAACK,CAAD,CAAH,KAAW,GAAf,EAAqB;AAC1BD,QAAAA,IAAI;AACL;;AAED,UAAIA,IAAI,KAAK,CAAb,EAAiB;AACf;AACA;AACA;AACA,eAAOR,gBAAgB,CAAEI,GAAG,CAACQ,OAAJ,CAAYL,KAAZ,EAAmBP,gBAAgB,CAAEO,KAAK,CAACM,KAAN,CAAY,CAAZ,EAAe,CAAC,CAAhB,CAAF,CAAnC,CAAF,CAAvB;AACD;AACF;AACF;;AAED,WAASV,eAAT,CAAyBL,QAAzB,EAAmC;AAAE;AACnCA,IAAAA,QAAQ,GAAGG,WAAW,CAACH,QAAD,CAAtB;AACAA,IAAAA,QAAQ,GAAGgB,OAAO,CAAChB,QAAD,CAAlB;AACAA,IAAAA,QAAQ,GAAGiB,UAAU,CAACjB,QAAD,CAArB;AAEA,WAAOA,QAAP;AAEA;;AAEA,aAASgB,OAAT,CAAiBhB,QAAjB,EAA2B;AACzB,UAAIkB,MAAM,GAAG,CAAClB,QAAQ,CAACmB,KAAT,CAAe,QAAf,KAA4B,EAA7B,EAAiCD,MAA9C;AACA,UAAI,CAACA,MAAL,EAAa,OAAOlB,QAAP;;AAEb,WAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGO,MAApB,EAA4BP,CAAC,EAA7B,EAAiC;AAC/BX,QAAAA,QAAQ,GAAGA,QAAQ,CAACc,OAAT,CACT,yCADS,EAET,UAASM,CAAT,EAAYC,CAAZ,EAAeC,IAAf,EAAqBC,CAArB,EAAwB;AACtB,iBAAO3B,IAAI,CAACyB,CAAD,EAAIC,IAAJ,EAAUC,CAAV,CAAX;AACD,SAJQ,CAAX;AAOAvB,QAAAA,QAAQ,GAAGG,WAAW,CAACH,QAAD,CAAtB,CAR+B,CAS/B;AACA;AACA;AACD;;AAED,aAAOA,QAAP;AACD;;AAED,aAASiB,UAAT,CAAoBjB,QAApB,EAA8B;AAC5B,UAAIkB,MAAM,GAAG,CAAClB,QAAQ,CAACmB,KAAT,CAAe,OAAf,KAA2B,EAA5B,EAAgCD,MAA7C;AACA,UAAI,CAACA,MAAL,EAAa,OAAOlB,QAAP;;AAEb,WAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGO,MAApB,EAA4BP,CAAC,EAA7B,EAAiC;AAC/BX,QAAAA,QAAQ,GAAGA,QAAQ,CAACc,OAAT,CACT,6CADS,EAET,UAASM,CAAT,EAAYC,CAAZ,EAAeC,IAAf,EAAqBC,CAArB,EAAwB;AACtB,iBAAO3B,IAAI,CAACyB,CAAD,EAAIC,IAAJ,EAAUC,CAAV,CAAX;AACD,SAJQ,CAAX;AAOAvB,QAAAA,QAAQ,GAAGG,WAAW,CAACH,QAAD,CAAtB;AACD;;AAED,aAAOA,QAAP;AACD;AACF;;AAED,WAASG,WAAT,CAAqBH,QAArB,EAA+B;AAC7B,WAAQA,QAAQ,CAAe;AAAf,KACbc,OADK,CACG,KADH,EACU,EADV,EACuB;AADvB,KAELA,OAFK,CAEG,OAFH,EAEY,EAFZ,EAEuB;AAFvB,KAGLA,OAHK,CAGG,KAHH,EAGU,GAHV,EAGuB;AAHvB,KAILA,OAJK,CAIG,mBAJH,EAIwB,CAACM,CAAD,EAAIE,IAAJ,KAAaA,IAAI,CAAC,CAAD,CAJzC,EAKG;AALH,KAMLR,OANK,CAMG,UANH,EAMe,GANf,EAMuB;AANvB,KAOLA,OAPK,CAOG,OAPH,EAOY,KAPZ,EAOuB;AAPvB,KAQLA,OARK,CAQG,SARH,EAQc,MARd,EAQuB;AARvB,KASLA,OATK,CASG,SATH,EASc,MATd,EASuB;AATvB,KAULA,OAVK,CAUG,YAVH,EAUiB,IAVjB,CAAR,CAU+B;AAV/B;AAYD;;AAED,WAASb,oBAAT,CAA8BD,QAA9B,EAAwC;AACtC,QAAIwB,WAAW,GAAG,CAACxB,QAAQ,CAACmB,KAAT,CAAe,KAAf,KAAyB,EAA1B,EAA8BD,MAAhD;AACA,QAAIO,YAAY,GAAG,CAACzB,QAAQ,CAACmB,KAAT,CAAe,KAAf,KAAyB,EAA1B,EAA8BD,MAAjD;;AAEA,QAAIM,WAAW,KAAKC,YAApB,EAAkC;AAChC,YAAM,IAAIC,KAAJ,CAAU,8BAA8B1B,QAAxC,CAAN;AACD;AACF;;AAED,WAASH,SAAT,GAAqB;AACnB,QAAI8B,UAAU,GAAG;AACf,WAAK,CAACN,CAAD,EAAIE,CAAJ,KAAUK,MAAM,CAACP,CAAD,CAAN,GAAYO,MAAM,CAACL,CAAD,CADlB;AAEf,WAAK,CAACF,CAAD,EAAIE,CAAJ,KAAUF,CAAC,GAAGE,CAFJ;AAGf,WAAK,CAACF,CAAD,EAAIE,CAAJ,KAAUF,CAAC,GAAGE,CAHJ;AAIf,WAAK,CAACF,CAAD,EAAIE,CAAJ,KAAU;AACb,YAAIA,CAAC,KAAK,GAAV,EAAgB;AACdzB,UAAAA,SAAS,GAAG,IAAZ;AACD;;AAED,eAAQuB,CAAC,GAAGE,CAAZ;AACD;AAVc,KAAjB;AAaA,WAAO,SAAS3B,IAAT,CAAcyB,CAAd,EAAiBQ,SAAjB,EAA4BN,CAA5B,EAA+B;AACpC,aAAOI,UAAU,CAACE,SAAD,CAAV,CAAsBR,CAAtB,EAAyBE,CAAzB,CAAP;AACD,KAFD;AAGD;AACF","sourcesContent":["export default function getMathHandler() {\n    const math = getMathFn();  \n    let divByZero = false;\n  \n    return applyMath;\n    \n    /***/\n  \n    function applyMath(math_str) {\n      divByZero = false;    \n      throwUnmatchedScopes(math_str);\n      \n      math_str = deepRemoveScopes(math_str);    \n      math_str = autoCorrect(math_str);\n  \n      let result = parseLinearMath(math_str);\n      return divByZero ? \"Караул, тут делят на ноль!\" : result;\n    }\n  \n  \n    function deepRemoveScopes(str) {    \n      str = autoCorrect(str);\n      \n      let index = str.indexOf(\"(\");\n      if( index === -1 ) return parseLinearMath(str);\n      \n      let scope = \"(\";\n      let open = 1;\n      \n      for( let i = index + 1; i <= 100000; i++ ) {\n        if( i === 100000 ) console.log(\"Кажется пошел бесконечный цикл\");\n        \n        scope += str[i];\n        \n        if( str[i] === \"(\" ) {\n          open++;\n        } else if( str[i] === \")\" ) {\n          open--;\n        }\n        \n        if( open === 0 ) {\n          // Привет, рекурсия!\n          // Показалось проще перезапускать функцию после каждой найденной скобки.\n          // При этом учитывая и вложенные скобки scope.slice(1, -1)\n          return deepRemoveScopes( str.replace(scope, deepRemoveScopes( scope.slice(1, -1) ) ) );\n        }\n      }\n    }\n    \n    function parseLinearMath(math_str) { /* уже точно нет скобок */\n      math_str = autoCorrect(math_str);\n      math_str = mul_div(math_str);\n      math_str = plus_minus(math_str);\n  \n      return math_str;\n  \n      /***/\n  \n      function mul_div(math_str) {\n        let length = (math_str.match(/\\/|\\*/g) || []).length;\n        if (!length) return math_str;\n  \n        for (let i = 0; i < length; i++) {\n          math_str = math_str.replace(\n            /(\\d+(?:\\.\\d+)?)(\\/|\\*)(-?\\d+(?:\\.\\d+)?)/,\n            function(_, a, oper, b) {\n              return math(a, oper, b);\n            }\n          );\n  \n          math_str = autoCorrect(math_str);\n          // Строка не из миллиона символов, поэтому после каждой операции\n          // На всякий случай исправляется всё, что может пойти не так.\n          // В основном, \"гасятся\" знаки вида ++, +-, --\n        }\n  \n        return math_str;\n      }\n  \n      function plus_minus(math_str) {\n        let length = (math_str.match(/\\+|-/g) || []).length;\n        if (!length) return math_str;\n  \n        for (let i = 0; i < length; i++) {\n          math_str = math_str.replace(\n            /((?:^-)?\\d+(?:\\.\\d+)?)(\\+|-)(\\d+(?:\\.\\d+)?)/,\n            function(_, a, oper, b) {\n              return math(a, oper, b);\n            }\n          );\n  \n          math_str = autoCorrect(math_str);\n        }\n  \n        return math_str;\n      }\n    }\n  \n    function autoCorrect(math_str) {\n      return (math_str               // Замены:\n        .replace(/\\s/g, \"\")          // Удалить все пробелы\n        .replace(/\\(\\)/g, \"\")        // Убрать пустые скобки\n        .replace(/--/g, \"+\")         // Два минуса подряд → Плюс\n        .replace(/(\\+\\+|\\*\\*|\\/\\/)/g, (_, oper) => oper[0])\n                 // Двойные плюсы, умножения и пр → на один\n        .replace(/\\+-|-\\+/g, \"-\")    // Плюс после минуса и наоборот → на минус\n        .replace(/\\)\\(/g, \")*(\")     // Две скобки подряд → вставить умножение\n        .replace(/(\\d)\\(/g, \"$1*(\")  // Число и сразу скобка → умножение\n        .replace(/\\)(\\d)/g, \")*$1\")  // Скобка и сразу число → умножение\n        .replace(/(\\/|\\*)\\+/g, \"$1\") // *+ или /+ → убрать плюс\n      );\n    }\n  \n    function throwUnmatchedScopes(math_str) {\n      let scopes_open = (math_str.match(/\\(/g) || []).length;\n      let scopes_close = (math_str.match(/\\)/g) || []).length;\n  \n      if (scopes_open !== scopes_close) {\n        throw new Error(\"Unmatched parenthesis at \" + math_str);\n      }\n    }\n  \n    function getMathFn() {\n      let local_math = {\n        \"+\": (a, b) => Number(a) + Number(b),\n        \"-\": (a, b) => a - b,\n        \"*\": (a, b) => a * b,\n        \"/\": (a, b) => {\n          if( b === \"0\" ) {\n            divByZero = true;\n          }\n          \n          return (a / b);\n        },\n      };\n  \n      return function math(a, operation, b) {\n        return local_math[operation](a, b);\n      }\n    }\n  }"]},"metadata":{},"sourceType":"module"}