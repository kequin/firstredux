{"ast":null,"code":"export default function applyMath(math_str) {\n  divByZero = false;\n  throwUnmatchedScopes(math_str);\n  math_str = deepRemoveScopes(math_str);\n  math_str = autoCorrect(math_str);\n  let result = parseLinearMath(math_str);\n  return divByZero ? \"Караул, тут делят на ноль!\" : result;\n}\n\nfunction deepRemoveScopes(str) {\n  str = autoCorrect(str);\n  let index = str.indexOf(\"(\");\n  if (index === -1) return parseLinearMath(str);\n  let scope = \"(\";\n  let open = 1;\n\n  for (let i = index + 1; i <= 100000; i++) {\n    if (i === 100000) console.log(\"Кажется пошел бесконечный цикл\");\n    scope += str[i];\n\n    if (str[i] === \"(\") {\n      open++;\n    } else if (str[i] === \")\") {\n      open--;\n    }\n\n    if (open === 0) {\n      // Привет, рекурсия!\n      // Показалось проще перезапускать функцию после каждой найденной скобки.\n      // При этом учитывая и вложенные скобки scope.slice(1, -1)\n      return deepRemoveScopes(str.replace(scope, deepRemoveScopes(scope.slice(1, -1))));\n    }\n  }\n}\n\nfunction parseLinearMath(math_str) {\n  /* уже точно нет скобок */\n  math_str = autoCorrect(math_str);\n  math_str = mul_div(math_str);\n  math_str = plus_minus(math_str);\n  return math_str;\n  /***/\n\n  function mul_div(math_str) {\n    let length = (math_str.match(/\\/|\\*/g) || []).length;\n    if (!length) return math_str;\n\n    for (let i = 0; i < length; i++) {\n      math_str = math_str.replace(/(\\d+(?:\\.\\d+)?)(\\/|\\*)(-?\\d+(?:\\.\\d+)?)/, function (_, a, oper, b) {\n        return math(a, oper, b);\n      });\n      math_str = autoCorrect(math_str); // Строка не из миллиона символов, поэтому после каждой операции\n      // На всякий случай исправляется всё, что может пойти не так.\n      // В основном, \"гасятся\" знаки вида ++, +-, --\n    }\n\n    return math_str;\n  }\n\n  function plus_minus(math_str) {\n    let length = (math_str.match(/\\+|-/g) || []).length;\n    if (!length) return math_str;\n\n    for (let i = 0; i < length; i++) {\n      math_str = math_str.replace(/((?:^-)?\\d+(?:\\.\\d+)?)(\\+|-)(\\d+(?:\\.\\d+)?)/, function (_, a, oper, b) {\n        return math(a, oper, b);\n      });\n      math_str = autoCorrect(math_str);\n    }\n\n    return math_str;\n  }\n}\n\nfunction autoCorrect(math_str) {\n  return math_str // Замены:\n  .replace(/\\s/g, \"\") // Удалить все пробелы\n  .replace(/\\(\\)/g, \"\") // Убрать пустые скобки\n  .replace(/--/g, \"+\") // Два минуса подряд → Плюс\n  .replace(/(\\+\\+|\\*\\*|\\/\\/)/g, (_, oper) => oper[0]) // Двойные плюсы, умножения и пр → на один\n  .replace(/\\+-|-\\+/g, \"-\") // Плюс после минуса и наоборот → на минус\n  .replace(/\\)\\(/g, \")*(\") // Две скобки подряд → вставить умножение\n  .replace(/(\\d)\\(/g, \"$1*(\") // Число и сразу скобка → умножение\n  .replace(/\\)(\\d)/g, \")*$1\") // Скобка и сразу число → умножение\n  .replace(/(\\/|\\*)\\+/g, \"$1\") // *+ или /+ → убрать плюс\n  ;\n}\n\nfunction throwUnmatchedScopes(math_str) {\n  let scopes_open = (math_str.match(/\\(/g) || []).length;\n  let scopes_close = (math_str.match(/\\)/g) || []).length;\n\n  if (scopes_open !== scopes_close) {\n    throw new Error(\"Unmatched parenthesis at \" + math_str);\n  }\n}\n\nfunction getMathFn() {\n  let local_math = {\n    \"+\": (a, b) => Number(a) + Number(b),\n    \"-\": (a, b) => a - b,\n    \"*\": (a, b) => a * b,\n    \"/\": (a, b) => {\n      if (b === \"0\") {\n        divByZero = true;\n      }\n\n      return a / b;\n    }\n  };\n}","map":{"version":3,"sources":["/home/taiga/Рабочий стол/govno/firstredax/src/applyMath.js"],"names":["applyMath","math_str","divByZero","throwUnmatchedScopes","deepRemoveScopes","autoCorrect","result","parseLinearMath","str","index","indexOf","scope","open","i","console","log","replace","slice","mul_div","plus_minus","length","match","_","a","oper","b","math","scopes_open","scopes_close","Error","getMathFn","local_math","Number"],"mappings":"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","sourcesContent":["export default function applyMath(math_str) {\n    divByZero = false;    \n    throwUnmatchedScopes(math_str);\n    \n    math_str = deepRemoveScopes(math_str);    \n    math_str = autoCorrect(math_str);\n\n    let result = parseLinearMath(math_str);\n    return divByZero ? \"Караул, тут делят на ноль!\" : result;\n  }\n\n\n  function deepRemoveScopes(str) {    \n    str = autoCorrect(str);\n    \n    let index = str.indexOf(\"(\");\n    if( index === -1 ) return parseLinearMath(str);\n    \n    let scope = \"(\";\n    let open = 1;\n    \n    for( let i = index + 1; i <= 100000; i++ ) {\n      if( i === 100000 ) console.log(\"Кажется пошел бесконечный цикл\");\n      \n      scope += str[i];\n      \n      if( str[i] === \"(\" ) {\n        open++;\n      } else if( str[i] === \")\" ) {\n        open--;\n      }\n      \n      if( open === 0 ) {\n        // Привет, рекурсия!\n        // Показалось проще перезапускать функцию после каждой найденной скобки.\n        // При этом учитывая и вложенные скобки scope.slice(1, -1)\n        return deepRemoveScopes( str.replace(scope, deepRemoveScopes( scope.slice(1, -1) ) ) );\n      }\n    }\n  }\n  \n  function parseLinearMath(math_str) { /* уже точно нет скобок */\n    math_str = autoCorrect(math_str);\n    math_str = mul_div(math_str);\n    math_str = plus_minus(math_str);\n\n    return math_str;\n\n    /***/\n\n    function mul_div(math_str) {\n      let length = (math_str.match(/\\/|\\*/g) || []).length;\n      if (!length) return math_str;\n\n      for (let i = 0; i < length; i++) {\n        math_str = math_str.replace(\n          /(\\d+(?:\\.\\d+)?)(\\/|\\*)(-?\\d+(?:\\.\\d+)?)/,\n          function(_, a, oper, b) {\n            return math(a, oper, b);\n          }\n        );\n\n        math_str = autoCorrect(math_str);\n        // Строка не из миллиона символов, поэтому после каждой операции\n        // На всякий случай исправляется всё, что может пойти не так.\n        // В основном, \"гасятся\" знаки вида ++, +-, --\n      }\n\n      return math_str;\n    }\n\n    function plus_minus(math_str) {\n      let length = (math_str.match(/\\+|-/g) || []).length;\n      if (!length) return math_str;\n\n      for (let i = 0; i < length; i++) {\n        math_str = math_str.replace(\n          /((?:^-)?\\d+(?:\\.\\d+)?)(\\+|-)(\\d+(?:\\.\\d+)?)/,\n          function(_, a, oper, b) {\n            return math(a, oper, b);\n          }\n        );\n\n        math_str = autoCorrect(math_str);\n      }\n\n      return math_str;\n    }\n  }\n\n  function autoCorrect(math_str) {\n    return (math_str               // Замены:\n      .replace(/\\s/g, \"\")          // Удалить все пробелы\n      .replace(/\\(\\)/g, \"\")        // Убрать пустые скобки\n      .replace(/--/g, \"+\")         // Два минуса подряд → Плюс\n      .replace(/(\\+\\+|\\*\\*|\\/\\/)/g, (_, oper) => oper[0])\n               // Двойные плюсы, умножения и пр → на один\n      .replace(/\\+-|-\\+/g, \"-\")    // Плюс после минуса и наоборот → на минус\n      .replace(/\\)\\(/g, \")*(\")     // Две скобки подряд → вставить умножение\n      .replace(/(\\d)\\(/g, \"$1*(\")  // Число и сразу скобка → умножение\n      .replace(/\\)(\\d)/g, \")*$1\")  // Скобка и сразу число → умножение\n      .replace(/(\\/|\\*)\\+/g, \"$1\") // *+ или /+ → убрать плюс\n    );\n  }\n\n  function throwUnmatchedScopes(math_str) {\n    let scopes_open = (math_str.match(/\\(/g) || []).length;\n    let scopes_close = (math_str.match(/\\)/g) || []).length;\n\n    if (scopes_open !== scopes_close) {\n      throw new Error(\"Unmatched parenthesis at \" + math_str);\n    }\n  }\n\n  function getMathFn() {\n    let local_math = {\n      \"+\": (a, b) => Number(a) + Number(b),\n      \"-\": (a, b) => a - b,\n      \"*\": (a, b) => a * b,\n      \"/\": (a, b) => {\n        if( b === \"0\" ) {\n          divByZero = true;\n        }\n        \n        return (a / b);\n      },\n    }\n}"]},"metadata":{},"sourceType":"module"}