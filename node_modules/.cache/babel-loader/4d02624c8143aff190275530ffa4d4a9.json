{"ast":null,"code":"export default function getMathHandler(str){var math=getMathFn();var divByZero=false;return applyMath(str);/***/function applyMath(math_str){divByZero=false;throwUnmatchedScopes(math_str);math_str=deepRemoveScopes(math_str);math_str=autoCorrect(math_str);var result=parseLinearMath(math_str);return divByZero?\"Караул, тут делят на ноль!\":result;}function deepRemoveScopes(str){str=autoCorrect(str);var index=str.indexOf(\"(\");if(index===-1)return parseLinearMath(str);var scope=\"(\";var open=1;for(var i=index+1;i<=100000;i++){if(i===100000)console.log(\"Кажется пошел бесконечный цикл\");scope+=str[i];if(str[i]===\"(\"){open++;}else if(str[i]===\")\"){open--;}if(open===0){// Привет, рекурсия!\n// Показалось проще перезапускать функцию после каждой найденной скобки.\n// При этом учитывая и вложенные скобки scope.slice(1, -1)\nreturn deepRemoveScopes(str.replace(scope,deepRemoveScopes(scope.slice(1,-1))));}}}function parseLinearMath(math_str){/* уже точно нет скобок */math_str=autoCorrect(math_str);math_str=mul_div(math_str);math_str=plus_minus(math_str);return math_str;/***/function mul_div(math_str){var length=(math_str.match(/\\/|\\*/g)||[]).length;if(!length)return math_str;for(var i=0;i<length;i++){math_str=math_str.replace(/(\\d+(?:\\.\\d+)?)(\\/|\\*)(-?\\d+(?:\\.\\d+)?)/,function(_,a,oper,b){return math(a,oper,b);});math_str=autoCorrect(math_str);// Строка не из миллиона символов, поэтому после каждой операции\n// На всякий случай исправляется всё, что может пойти не так.\n// В основном, \"гасятся\" знаки вида ++, +-, --\n}return math_str;}function plus_minus(math_str){var length=(math_str.match(/\\+|-/g)||[]).length;if(!length)return math_str;for(var i=0;i<length;i++){math_str=math_str.replace(/((?:^-)?\\d+(?:\\.\\d+)?)(\\+|-)(\\d+(?:\\.\\d+)?)/,function(_,a,oper,b){return math(a,oper,b);});math_str=autoCorrect(math_str);}return math_str;}}function autoCorrect(math_str){return math_str// Замены:\n.replace(/\\s/g,\"\")// Удалить все пробелы\n.replace(/\\(\\)/g,\"\")// Убрать пустые скобки\n.replace(/--/g,\"+\")// Два минуса подряд → Плюс\n.replace(/(\\+\\+|\\*\\*|\\/\\/)/g,function(_,oper){return oper[0];})// Двойные плюсы, умножения и пр → на один\n.replace(/\\+-|-\\+/g,\"-\")// Плюс после минуса и наоборот → на минус\n.replace(/\\)\\(/g,\")*(\")// Две скобки подряд → вставить умножение\n.replace(/(\\d)\\(/g,\"$1*(\")// Число и сразу скобка → умножение\n.replace(/\\)(\\d)/g,\")*$1\")// Скобка и сразу число → умножение\n.replace(/(\\/|\\*)\\+/g,\"$1\")// *+ или /+ → убрать плюс\n;}function throwUnmatchedScopes(math_str){var scopes_open=(math_str.match(/\\(/g)||[]).length;var scopes_close=(math_str.match(/\\)/g)||[]).length;if(scopes_open!==scopes_close){throw new Error(\"Unmatched parenthesis at \"+math_str);}}function getMathFn(){var local_math={\"+\":function _(a,b){return Number(a)+Number(b);},\"-\":function _(a,b){return a-b;},\"*\":function _(a,b){return a*b;},\"/\":function _(a,b){if(b===\"0\"){divByZero=true;}return a/b;}};return function math(a,operation,b){return local_math[operation](a,b);};}}","map":{"version":3,"sources":["/home/taiga/Рабочий стол/govno/firstredax/src/assets/applyMath.js"],"names":["getMathHandler","str","math","getMathFn","divByZero","applyMath","math_str","throwUnmatchedScopes","deepRemoveScopes","autoCorrect","result","parseLinearMath","index","indexOf","scope","open","i","console","log","replace","slice","mul_div","plus_minus","length","match","_","a","oper","b","scopes_open","scopes_close","Error","local_math","Number","operation"],"mappings":"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","sourcesContent":["export default function getMathHandler(str) {\n    const math = getMathFn();  \n    let divByZero = false;\n  \n    return applyMath(str);\n    \n    /***/\n  \n    function applyMath(math_str) {\n      divByZero = false;    \n      throwUnmatchedScopes(math_str);\n      \n      math_str = deepRemoveScopes(math_str);    \n      math_str = autoCorrect(math_str);\n  \n      let result = parseLinearMath(math_str);\n      return divByZero ? \"Караул, тут делят на ноль!\" : result;\n    }\n  \n  \n    function deepRemoveScopes(str) {    \n      str = autoCorrect(str);\n      \n      let index = str.indexOf(\"(\");\n      if( index === -1 ) return parseLinearMath(str);\n      \n      let scope = \"(\";\n      let open = 1;\n      \n      for( let i = index + 1; i <= 100000; i++ ) {\n        if( i === 100000 ) console.log(\"Кажется пошел бесконечный цикл\");\n        \n        scope += str[i];\n        \n        if( str[i] === \"(\" ) {\n          open++;\n        } else if( str[i] === \")\" ) {\n          open--;\n        }\n        \n        if( open === 0 ) {\n          // Привет, рекурсия!\n          // Показалось проще перезапускать функцию после каждой найденной скобки.\n          // При этом учитывая и вложенные скобки scope.slice(1, -1)\n          return deepRemoveScopes( str.replace(scope, deepRemoveScopes( scope.slice(1, -1) ) ) );\n        }\n      }\n    }\n    \n    function parseLinearMath(math_str) { /* уже точно нет скобок */\n      math_str = autoCorrect(math_str);\n      math_str = mul_div(math_str);\n      math_str = plus_minus(math_str);\n  \n      return math_str;\n  \n      /***/\n  \n      function mul_div(math_str) {\n        let length = (math_str.match(/\\/|\\*/g) || []).length;\n        if (!length) return math_str;\n  \n        for (let i = 0; i < length; i++) {\n          math_str = math_str.replace(\n            /(\\d+(?:\\.\\d+)?)(\\/|\\*)(-?\\d+(?:\\.\\d+)?)/,\n            function(_, a, oper, b) {\n              return math(a, oper, b);\n            }\n          );\n  \n          math_str = autoCorrect(math_str);\n          // Строка не из миллиона символов, поэтому после каждой операции\n          // На всякий случай исправляется всё, что может пойти не так.\n          // В основном, \"гасятся\" знаки вида ++, +-, --\n        }\n  \n        return math_str;\n      }\n  \n      function plus_minus(math_str) {\n        let length = (math_str.match(/\\+|-/g) || []).length;\n        if (!length) return math_str;\n  \n        for (let i = 0; i < length; i++) {\n          math_str = math_str.replace(\n            /((?:^-)?\\d+(?:\\.\\d+)?)(\\+|-)(\\d+(?:\\.\\d+)?)/,\n            function(_, a, oper, b) {\n              return math(a, oper, b);\n            }\n          );\n  \n          math_str = autoCorrect(math_str);\n        }\n  \n        return math_str;\n      }\n    }\n  \n    function autoCorrect(math_str) {\n      return (math_str               // Замены:\n        .replace(/\\s/g, \"\")          // Удалить все пробелы\n        .replace(/\\(\\)/g, \"\")        // Убрать пустые скобки\n        .replace(/--/g, \"+\")         // Два минуса подряд → Плюс\n        .replace(/(\\+\\+|\\*\\*|\\/\\/)/g, (_, oper) => oper[0])\n                 // Двойные плюсы, умножения и пр → на один\n        .replace(/\\+-|-\\+/g, \"-\")    // Плюс после минуса и наоборот → на минус\n        .replace(/\\)\\(/g, \")*(\")     // Две скобки подряд → вставить умножение\n        .replace(/(\\d)\\(/g, \"$1*(\")  // Число и сразу скобка → умножение\n        .replace(/\\)(\\d)/g, \")*$1\")  // Скобка и сразу число → умножение\n        .replace(/(\\/|\\*)\\+/g, \"$1\") // *+ или /+ → убрать плюс\n      );\n    }\n  \n    function throwUnmatchedScopes(math_str) {\n      let scopes_open = (math_str.match(/\\(/g) || []).length;\n      let scopes_close = (math_str.match(/\\)/g) || []).length;\n  \n      if (scopes_open !== scopes_close) {\n        throw new Error(\"Unmatched parenthesis at \" + math_str);\n      }\n    }\n  \n    function getMathFn() {\n      let local_math = {\n        \"+\": (a, b) => Number(a) + Number(b),\n        \"-\": (a, b) => a - b,\n        \"*\": (a, b) => a * b,\n        \"/\": (a, b) => {\n          if( b === \"0\" ) {\n            divByZero = true;\n          }\n          \n          return (a / b);\n        },\n      };\n  \n      return function math(a, operation, b) {\n        return local_math[operation](a, b);\n      }\n    }\n  }"]},"metadata":{},"sourceType":"module"}